# This is a TOML 0.4.0 file, as specified by https://github.com/toml-lang/toml.

# Uncomment this line to serve only to localhost clients, e.g. for testing, by
# binding on the loopback interface.
# LocalOnly = true

# This is the URL prefix under which the packager is being served on the open
# internet. This is used to generate certUrls, by appending
# "/amppkg/cert/blahblahblah". (In the future, it may have other uses.) This is
# NOT the URL where the packager responds, which will instead be anchored to
# the root path.
#
# For instance, if PackagerBase = "https://example.com/", then the frontend
# server should reverse-proxy all URLs matching:
#   https://example.com/amppkg/(.*)
# to the packager.
#
# Alternatively, if PackagerBase = "https://example.com/packager/", then the
# frontend server should reverse-proxy all URLs matching:
#   https://example.com/packager/amppkg/(.*)
# to the packager, removing the "/packager" prefix from the path.
#
# The frontend MUST NOT forward any requests for /amppkg-priv/.* to the
# packager. Doing so would allow users to sign the wrong URL on documents. (See
# URLSet below for some mitigation of this.)
PackagerBase = 'https://example.com/'

# The path to the PEM file containing the full certificate chain, ordered from
# leaf to root. This will be served at /amppkg/cert/blahblahblah, where
# "blahblahblah" is a stable unique identifier for the cert (currently, its
# base64-encoded SHA-256).
#
# This certificate must be one of: 2048-bit RSA, EC with the secp256r1 curve,
# or EC with the secp384r1 curve. (See https://goo.gl/E3YNkq item 5.1.4.)
#
# To mitigate the risk of an attacker gaining access to your private key
# through a vulnerability in this packager, you should generate a new
# certificate/key pair for the domain(s) you wish to sign packages with. This
# allows you to revoke that certificate without affecting your normal
# web-serving traffic.
CertFile = './pems/cert.pem'

# The path to the PEM file containing the private key that corresponds to the
# leaf certificate in CertFile.
KeyFile = './pems/privkey.pem'

# The API key obtained from https://console.cloud.google.com/ with access to
# the AMP HTML Transformer API, per these instructions:
# https://support.google.com/cloud/answer/6158862
GoogleAPIKey = "asdfghjkl"

# This is a simple level of validation, to guard against accidental
# misconfiguration of the reverse proxy that sits in front of the packager.
#
# You must specify at least one URLSet; you may specify multiple. Each one must
# specify a Fetch pattern and a Sign pattern. When the packager receives a
# request for a package, it will first validate that the requested fetch/sign
# URL pair matches at least one of the given URLSets.
#
# This config doesn't let you specify an exact URL-to-URL mapping between fetch
# and sign. If an attacker gains direct access to this packager, they could ask
# it to fetch https://www.example.com/foo.html and sign it as
# https://example.com/bar.html.
#
# Instead, it is the responsibility of the frontend that sits in front of the
# packager to properly rewrite requests for a package into the appropriate
# fetch/sign pair. For instance, the frontend server may reverse-proxy all URLs
# matching:
#   https://example.com/wpk/(.*)
# to:
#   http://packager.internal/priv/doc?fetch=https%3A%2F%2Fexample.com%2F\1&sign=https%3A%2F%2Fexample.com%2F\1
# where \1 is the URL-escaped value of the regexp group matched above.
[[URLSet]]
  # If true, enforces that the path and query are the same between the fetch
  # and sign URLs (e.g. respond in error if
  # fetch=http%3A%2F%2Ffoo%2Fbar.html and
  # sign=https%3A%2F%2Fbaz%2Fnot-bar.html).
  # Default is false.
  # SamePath = true

  # Where to fetch the raw AMP HTML. The HTTP response from this fetch URL must
  # be a 200, and must have Cache-Control: public; otherwise, the packager will
  # respond with an error code.
  [URLSet.Fetch]
    # The set of allowed schemes. Default is ["https"]. You may configure it to
    # be ["http"] or ["http", "https"] instead. (No other value is allowed.)
    #
    # The scheme is strongly encouraged to be https, to avoid a potential for a
    # MITM attack.
    Scheme = ["https"]

    # The `user:pass@` portion of the URL is disallowed. There is no way to configure this.

    # The domain from where to fetch. An exact string match.
    Domain = "www.corp.example.com"  # Exact string match on domain. Required.

    # A full-match regexp on the path to fetch (not including the ?query).
    # Defaults to ".*". The below example only allows paths starting with /world/.
    # PathRE = "/world/.*"

    # A list of full-match regexps, carving out exclusions to the above PathRE.
    # Examples of paths you might want to exclude:
    #   * Personalized content, such as user settings pages. Signed exchanges
    #     are cached globally and served to all users. (Personalization that
    #     happens at runtime via JS is fine.) This provides defense-in-depth,
    #     in addition to the Cache-Control: public check.
    #   * User-generated content, such as forums. For instance, if there's a
    #     chance of an XSS vulnerability in your templating library, the impact
    #     of such event is higher here: even after you've fixed the bug, caches
    #     may serve your signed packages for up to 7 days.
    PathExcludeRE = []

    # A full-match regexp on the query portion of the URL, excluding the initial
    # "?". Defaults to ".*". The below example disallows non-empty query strings
    # (though a single "?" is allowed).
    # QueryRE = ""

    # The fragment portion of the URL (i.e. the '#' and everything after) must
    # be empty. There is no way to configure this.

    # By default, stateful headers (such as Set-Cookie and WWW-Authenticate)
    # are stripped from the response before packaging. If instead you wish for
    # this to cause packaging to fail, set ErrorOnStatefulHeaders = true.
    # ErrorOnStatefulHeaders = true

  # What URLs will show up in the browser's URL bar, when served from the AMP Cache.
  [URLSet.Sign]
    # For Sign URLs, Scheme defaults to, and must be ["https"].
    # All other fields behave the same.
    # The domain must be one that the above CertFile/KeyFile can sign for.
    Domain = "example.com"
    # PathRE = "/world/.*"
    # QueryRE = ""
